/**
 * Acceptance Report Generator
 * 
 * Usage: 
 *   npm run report -- <run-id>
 *   npm run report  # uses latest run
 * 
 * Generates a detailed Markdown report for a sync run.
 */

const { query, close } = require('../src/db');
const fs = require('fs');
const path = require('path');

async function generateReport(runId) {
  try {
    // Get run info
    let runQuery;
    if (runId) {
      runQuery = await query('SELECT * FROM runs WHERE id = $1', [runId]);
    } else {
      runQuery = await query('SELECT * FROM runs ORDER BY started_at DESC LIMIT 1');
    }
    
    if (runQuery.rows.length === 0) {
      console.error('No runs found');
      process.exit(1);
    }
    
    const run = runQuery.rows[0];
    const actualRunId = run.id;
    
    // Get selected accounts
    const selectedQuery = await query(`
      SELECT sa.*, a.strict_win_rate, a.proxy_win_rate, a.total_volume_usd, a.total_trades
      FROM selected_accounts sa
      JOIN accounts a ON sa.address = a.address
      WHERE sa.run_id = $1
      ORDER BY sa.selection_score DESC
    `, [actualRunId]);
    
    const selectedAccounts = selectedQuery.rows;
    
    // Get snapshots count
    const snapshotQuery = await query(
      'SELECT COUNT(*) as count FROM account_metrics_snapshot WHERE run_id = $1',
      [actualRunId]
    );
    const snapshotCount = parseInt(snapshotQuery.rows[0].count);
    
    // Parse stats
    const stats = run.stats || {};
    const config = run.config || {};
    const errorSummary = stats.error_summary || {};
    
    // Calculate metrics
    const avgWinRate = selectedAccounts.length > 0
      ? selectedAccounts.reduce((sum, a) => sum + (a.strict_win_rate || a.proxy_win_rate || 0), 0) / selectedAccounts.length
      : 0;
    const avgVolume = selectedAccounts.length > 0
      ? selectedAccounts.reduce((sum, a) => sum + (a.total_volume_usd || 0), 0) / selectedAccounts.length
      : 0;
    const avgScore = selectedAccounts.length > 0
      ? selectedAccounts.reduce((sum, a) => sum + (Number(a.selection_score) || 0), 0) / selectedAccounts.length
      : 0;
    const topScore = selectedAccounts.length > 0 ? Number(selectedAccounts[0].selection_score) : null;
    
    // Calculate duration
    const duration = run.completed_at && run.started_at
      ? Math.round((new Date(run.completed_at) - new Date(run.started_at)) / 1000)
      : 0;
    
    // Generate report
    const report = `# Polymarket Winner Scanner - Sync Run Report

**Run ID**: \`${actualRunId}\`
**Date**: ${run.started_at ? new Date(run.started_at).toISOString() : 'N/A'}
**Status**: ${run.status}

---

## Summary

| Metric | Value |
|--------|-------|
| Accounts Processed | ${stats.accounts_processed || 0} |
| Accounts Selected | ${selectedAccounts.length} |
| Accounts Failed | ${stats.accounts_failed || 0} |
| Average Win Rate | ${(avgWinRate * 100).toFixed(1)}% |
| Average Volume | $${avgVolume.toFixed(2)} |
| Average Score | ${avgScore.toFixed(4)} |
| Top Score | ${topScore !== null ? topScore.toFixed(4) : 'N/A'} |

---

## Configuration

\`\`\`json
${JSON.stringify(config, null, 2)}
\`\`\`

---

## Top Selected Accounts

| Rank | Address | Win Rate | Volume (USD) | Score | Tags |
|------|---------|----------|--------------|-------|------|
${selectedAccounts.slice(0, 10).map((acc, i) => {
  const winRate = ((acc.strict_win_rate || acc.proxy_win_rate || 0) * 100).toFixed(1);
  const volume = (acc.total_volume_usd || 0).toFixed(2);
  const score = (acc.selection_score || 0).toFixed(4);
  const tags = acc.reason_tags || [];
  return `| ${i + 1} | \`${acc.address.slice(0, 10)}...\` | ${winRate}% | $${volume} | ${score} | ${tags.slice(0, 3).join(', ')} |`;
}).join('\n')}

${selectedAccounts.length === 0 ? '_No accounts selected in this run_' : ''}

---

## Error Summary

${errorSummary.hasErrors ? `
**Total Errors**: ${errorSummary.error_count}

| Error Type | Count |
|------------|-------|
${Object.entries(errorSummary.errors_by_type || {}).map(([type, count]) => `| ${type} | ${count} |`).join('\n')}

### Sample Errors
${(errorSummary.sample_errors || []).map(e => `
**${e.type}** (${e.count} occurrences):
${e.samples.map(s => `- \`${s.address?.slice(0, 10) || 'N/A'}...\`: ${s.message}`).join('\n')}
`).join('\n')}
` : '_No errors occurred during this run_'}

---

## Run Statistics

- **Started**: ${run.started_at || 'N/A'}
- **Completed**: ${run.completed_at || 'N/A'}
- **Duration**: ${duration} seconds
- **Snapshots Created**: ${snapshotCount}

---

## Next Steps

1. Review selected accounts for investment consideration
2. Monitor top performers for continued success
3. Adjust thresholds if needed for future runs

---

*Generated by polymarket-winner-scanner*
`;

    // Write report
    const reportsDir = path.join(__dirname, '..', 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const filename = `report-${actualRunId.slice(0, 8)}-${timestamp}.md`;
    const filepath = path.join(reportsDir, filename);
    
    fs.writeFileSync(filepath, report);
    
    console.log(`\n========== Report Generated ==========`);
    console.log(`Run ID: ${actualRunId}`);
    console.log(`Status: ${run.status}`);
    console.log(`Accounts Selected: ${selectedAccounts.length}`);
    console.log(`Report saved to: ${filepath}`);
    console.log(`======================================\n`);
    
    return filepath;
    
  } catch (error) {
    console.error('Failed to generate report:', error.message);
    process.exit(1);
  } finally {
    await close();
  }
}

// Parse args
const runIdArg = process.argv[2];
generateReport(runIdArg);
